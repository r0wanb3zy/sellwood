<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=5, viewport-fit=cover"
  />
  <title>2100×3700 mm Grid Plotter (no labels)</title>
  <style>
    :root {
      --ui-bg: #f8f9fb;
      --ui-border: rgba(0, 0, 0, 0.12);
      --minor: rgba(0, 0, 0, 0.5);
      --major: rgba(0, 0, 0, 1);
      --accent: #e53935;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body {
      font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial;
      color: #222;
      background: #fff;
    }

    /* App layout: controls on top, grid fills remaining height */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh; /* fallback */
      width: 100%;
    }
    @supports (height: 100dvh) {
      .app { height: 100dvh; } /* more accurate on mobile browsers */
    }

    /* Top-centered controls */
    .controls {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 14px;
      padding: 10px;
      background: var(--ui-bg);
      border-bottom: 1px solid var(--ui-border);
      flex-wrap: wrap;
    }
    .row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    label { font-size: 13px; }
    input[type="number"] {
      width: 80px;
      padding: 8px 10px;
      border: 1px solid var(--ui-border);
      border-radius: 8px;
      background: #fff;
      color: #111;
      -moz-appearance: textfield;
    }
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .hint { font-size: 12px; opacity: 0.7; }

    .stage {
      flex: 1 1 auto;
      min-width: 0;
      min-height: 0;
      position: relative;
      background: #fff;
    }
    #grid {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;
      touch-action: pinch-zoom; /* allow pinch zoom (cannot zoom out past 1× due to viewport meta) */
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="controls" aria-label="Plot point controls">
      <div class="row">
        <input id="xmm" type="number" step="1" value="0" inputmode="decimal" />
      </div>
      <div class="row">
        <input id="ymm" type="number" step="1" value="0" inputmode="decimal" />
      </div>
    </div>

    <main class="stage">
      <canvas id="grid" aria-label="Millimeter grid canvas without labels"></canvas>
    </main>
  </div>

<script>
  (function () {
    const MM_W = 2100;        // grid width in mm
    const MM_H = 3700;        // grid height in mm
    const EXTRA_TOP_MM = 130; // visible headroom above 0 (negative Y)
    const MAJOR_MM = 100;     // major step
    const MINOR_MM = 50;      // minor step
    const FIT = 'height';     // fill stage height

    // Target line thickness in mm (tweak to taste)
    const MINOR_MM_THICK = 0.25;
    const MAJOR_MM_THICK = .5;

    // Your SVG
    const SVG_URL = 'https://raw.githubusercontent.com/r0wanb3zy/sellwood/5df789a1d288cb26fa1f617eed1e8475cd48e9d6/images/grid/D36.svg';

    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d', { alpha: false });

    const xInput = document.getElementById('xmm');
    const yInput = document.getElementById('ymm');
    const stage = document.querySelector('.stage');

    // Effective DPR includes pinch-zoom scale
    let dpr = 1;

    function getEffectiveDpr() {
      const base = Math.max(1, window.devicePixelRatio || 1);
      const zoom = (window.visualViewport && window.visualViewport.scale) ? window.visualViewport.scale : 1;
      // Cap to avoid huge canvases on extreme zoom (tweak as needed)
      return Math.min(6, base * zoom);
    }

    let svgInfo = null; // holds loaded SVG + size in mm

    // Throttle expensive resizes to animation frames
    let rafId = 0;
    function scheduleResize() {
      if (rafId) return;
      rafId = requestAnimationFrame(() => {
        rafId = 0;
        resizeCanvas();
      });
    }

    function resizeCanvas() {
      dpr = getEffectiveDpr();

      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width * dpr));
      const h = Math.max(1, Math.round(rect.height * dpr));

      if (canvas.width !== w) canvas.width = w;
      if (canvas.height !== h) canvas.height = h;

      // 1 CSS px in the drawing API == 1 CSS px on the page
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false; // keeps raster overlays sharper

      draw();
    }

    function computeLayout() {
      const width = canvas.width / dpr;   // CSS px
      const height = canvas.height / dpr; // CSS px

      const MM_TOTAL_H = MM_H + EXTRA_TOP_MM;

      let scale, gridW, gridH, gridLeft, gridTop;

      if (FIT === 'width') {
        scale = width / MM_W;
        gridW = width;
        gridH = MM_TOTAL_H * scale;
        gridLeft = 0;
        gridTop = Math.max(0, (height - gridH) / 2);
      } else if (FIT === 'contain') {
        scale = Math.min(width / MM_W, height / MM_TOTAL_H);
        gridW = MM_W * scale;
        gridH = MM_TOTAL_H * scale;
        gridLeft = Math.max(0, (width - gridW) / 2);
        gridTop = Math.max(0, (height - gridH) / 2);
      } else { // 'height'
        scale = height / MM_TOTAL_H;
        gridH = height;
        gridW = MM_W * scale;
        gridLeft = Math.max(0, (width - gridW) / 2);
        gridTop = 0;
      }
      return { width, height, scale, gridW, gridH, gridLeft, gridTop };
    }

    // Line widths in CSS px derived from mm target (consistent across devices)
    function lineWidths(scale) {
      // scale = CSS px per mm
      const minorCss = MINOR_MM_THICK * scale;
      const majorCss = MAJOR_MM_THICK * scale;

      // If you prefer crisp hairlines on very small scales, uncomment this clamp:
      // const oneDevicePxCss = 1 / dpr;
      // return { minor: Math.max(minorCss, oneDevicePxCss), major: Math.max(majorCss, oneDevicePxCss) };

      return { minor: minorCss, major: majorCss };
    }

    // Snap the stroke center onto the device pixel grid when possible
    function crispCoord(v, lineWidthCss) {
      const lwDev = lineWidthCss * dpr;
      const isInt = Math.abs(lwDev - Math.round(lwDev)) < 1e-6;
      const isOddDevicePx = isInt && (Math.round(lwDev) % 2 === 1);
      const centerOffsetDev = isOddDevicePx ? 0.5 : 0; // 1px stroke centers at N+0.5 device px
      return (Math.round(v * dpr) + centerOffsetDev) / dpr;
    }

    function draw() {
      const { width, height, scale, gridW, gridH, gridLeft, gridTop } = computeLayout();
      const { minor, major } = lineWidths(scale);

      // Clear
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);

      drawGrid({ scale, gridW, gridH, gridLeft, gridTop, minorLW: minor, majorLW: major });
      drawSvgOverlay({ scale, gridLeft, gridTop }); // anchored to 0 mm (below)
      drawDot({ scale, gridLeft, gridTop });
    }

    function drawGrid({ scale, gridW, gridH, gridLeft, gridTop, minorLW, majorLW }) {
      const minorColor = getComputedStyle(document.documentElement).getPropertyValue('--minor').trim() || '#d9d9d9';
      const majorColor = getComputedStyle(document.documentElement).getPropertyValue('--major').trim() || '#7a7a7a';

      const yMin = -EXTRA_TOP_MM;
      const yMax = MM_H;

      ctx.save();
      // Extend clipping region by 1 CSS pixel to ensure right border is fully visible
      const clipPadding = 1 / dpr; // 1 device pixel in CSS pixels
      ctx.beginPath();
      ctx.rect(gridLeft, gridTop, gridW + clipPadding, gridH);
      ctx.clip();

      // Minor lines (every 50 mm)
      ctx.strokeStyle = minorColor;
      ctx.lineWidth = minorLW;

      // Vertical (X) minor lines
      for (let xm = MINOR_MM; xm < MM_W; xm += MINOR_MM) {
        if (xm % MAJOR_MM === 0) continue;
        const x = crispCoord(gridLeft + xm * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(x, gridTop);
        ctx.lineTo(x, gridTop + gridH);
        ctx.stroke();
      }
      // Horizontal (Y) minor lines include negatives
      for (let ym = Math.ceil(yMin / MINOR_MM) * MINOR_MM; ym < yMax; ym += MINOR_MM) {
        if (ym % MAJOR_MM === 0) continue;
        const y = crispCoord(gridTop + (ym + EXTRA_TOP_MM) * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(gridLeft, y);
        ctx.lineTo(gridLeft + gridW, y);
        ctx.stroke();
      }

      // Major lines (every 100 mm)
      ctx.strokeStyle = majorColor;
      ctx.lineWidth = majorLW;

      for (let xm = 0; xm <= MM_W; xm += MAJOR_MM) {
        const x = crispCoord(gridLeft + xm * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(x, gridTop);
        ctx.lineTo(x, gridTop + gridH);
        ctx.stroke();
      }
      for (let ym = Math.ceil(yMin / MAJOR_MM) * MAJOR_MM; ym <= yMax; ym += MAJOR_MM) {
        const y = crispCoord(gridTop + (ym + EXTRA_TOP_MM) * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(gridLeft, y);
        ctx.lineTo(gridLeft + gridW, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawDot({ scale, gridLeft, gridTop }) {
      const xmm = parseFloat(xInput.value);
      const ymm = parseFloat(yInput.value);
      if (!isFinite(xmm) || !isFinite(ymm)) return;

      const x = gridLeft + xmm * scale;
      const y = gridTop + (EXTRA_TOP_MM + ymm) * scale; // shift by the extra top mm
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#e53935';

      const r = 3; // CSS px radius; scales with DPR for smooth circles
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = accent;
      ctx.fill();
      ctx.restore();
    }

    // Draw the SVG on top of the grid at 1:1 mm scale, anchored at 0 mm
    function drawSvgOverlay({ scale, gridLeft, gridTop }) {
      if (!svgInfo || !svgInfo.img || !svgInfo.mmSize.width || !svgInfo.mmSize.height) return;

      const destW = svgInfo.mmSize.width * scale;   // px
      const destH = svgInfo.mmSize.height * scale;  // px
      const dx = gridLeft;                          // align left to grid
      const dy = gridTop;                           // align top to extended grid

      ctx.save();
      // Clip to grid bounds, expanded by half a device pixel to avoid trimming
      const half = 0.5 / dpr; // CSS px
      ctx.beginPath();
      ctx.rect(gridLeft - half, gridTop - half, MM_W * scale + 2 * half, (MM_H + EXTRA_TOP_MM) * scale + 2 * half);
      ctx.clip();

      ctx.drawImage(svgInfo.img, dx, dy, destW, destH);
      ctx.restore();
    }

    // Helpers: load/measure the SVG in mm
    function parseLengthToMm(val) {
      if (!val) return null;
      const m = String(val).trim().match(/^(-?\d+(\.\d+)?)([a-z%]*)$/i);
      if (!m) return null;
      const num = parseFloat(m[1]);
      const unit = (m[3] || '').toLowerCase();
      const mmPerUnit = {
        mm: 1,
        cm: 10,
        in: 25.4,
        pt: 25.4 / 72,
        pc: 25.4 / 6,
        px: 25.4 / 96,
        q: 0.25
      };
      const k = unit ? mmPerUnit[unit] : 1; // no unit => assume mm
      if (!k) return null;
      return num * k;
    }

    async function loadSvgInfo(url) {
      const [img, meta] = await Promise.all([
        new Promise((resolve, reject) => {
          const i = new Image();
          i.crossOrigin = 'anonymous';
          i.onload = () => resolve(i);
          i.onerror = reject;
          i.src = url;
        }),
        fetch(url, { mode: 'cors' })
          .then(r => r.text())
          .then(txt => {
            const doc = new DOMParser().parseFromString(txt, 'image/svg+xml');
            const svg = doc.documentElement;
            const viewBox = svg.getAttribute('viewBox');
            let minX = 0, minY = 0, vbW = 0, vbH = 0;
            if (viewBox) {
              const p = viewBox.trim().split(/[\s,]+/).map(Number);
              if (p.length === 4) [minX, minY, vbW, vbH] = p;
            }
            const widthMm = parseLengthToMm(svg.getAttribute('width'));
            const heightMm = parseLengthToMm(svg.getAttribute('height'));

            let mmPerUnitX = (vbW && widthMm != null) ? widthMm / vbW : null;
            let mmPerUnitY = (vbH && heightMm != null) ? heightMm / vbH : null;
            if (mmPerUnitX == null && mmPerUnitY != null) mmPerUnitX = mmPerUnitY;
            if (mmPerUnitY == null && mmPerUnitX != null) mmPerUnitY = mmPerUnitX;
            if (mmPerUnitX == null || mmPerUnitY == null) {
              mmPerUnitX = mmPerUnitY = 1;
            }

            const mmW = widthMm ?? (vbW ? vbW * mmPerUnitX : null);
            const mmH = heightMm ?? (vbH ? vbH * mmPerUnitY : null);

            return {
              vb: { minX, minY, width: vbW, height: vbH },
              mmSize: { width: mmW, height: mmH },
              mmPerUnit: { x: mmPerUnitX, y: mmPerUnitY }
            };
          })
      ]);
      return { img, ...meta };
    }

    // Init
    resizeCanvas();

    // Load overlay then draw
    loadSvgInfo(SVG_URL)
      .then(info => { svgInfo = info; draw(); })
      .catch(err => console.error('SVG load/parse failed:', err));

    // Keep canvas sized to viewport and layout changes
    window.addEventListener('resize', scheduleResize);
    window.addEventListener('orientationchange', scheduleResize);

    if ('ResizeObserver' in window) {
      const ro = new ResizeObserver(() => scheduleResize());
      ro.observe(stage);
    }

    // Redraw when pinch-zooming or panning the visual viewport
    if (window.visualViewport) {
      visualViewport.addEventListener('resize', scheduleResize, { passive: true });
      visualViewport.addEventListener('scroll', scheduleResize, { passive: true });
    }

    // Dynamic inputs
    xInput.addEventListener('input', draw);
    yInput.addEventListener('input', draw);
    [xInput, yInput].forEach(el =>
      el.addEventListener('keydown', e => { if (e.key === 'Enter') draw(); })
    );
  })();
</script>
</body>
</html>
