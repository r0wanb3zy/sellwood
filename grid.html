<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=5, viewport-fit=cover"
  />
  <title>Attic Ladder Grid</title>
  <style>
    :root {
      --ui-bg: #f8f9fb;
      --ui-border: rgba(0, 0, 0, 0.12);
      --minor: rgba(0, 0, 0, 0.5);
      --major: rgba(0, 0, 0, 1);
      --accent: #e53935;

      /* label styling */
      --label-color: #111;
      --label-halo: rgba(255, 255, 255, 0.92);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }

    /* Prevent pull-to-refresh / overscroll bounce where supported (Chrome Android, modern Safari) */
    html, body, .stage {
      overscroll-behavior-y: none;
      overscroll-behavior-x: none;
    }

    body {
      font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial;
      color: #222;
      background: #fff;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh; /* fallback */
      width: 100%;
    }
    @supports (height: 100dvh) {
      .app { height: 100dvh; }
    }

    .controls {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 14px;
      padding: 10px;
      background: var(--ui-bg);
      border-bottom: 1px solid var(--ui-border);
      flex-wrap: wrap;
    }
    .row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    label { font-size: 13px; }
    input[type="number"] {
      width: 60px;
      padding: 8px 10px;
      border: 1px solid var(--ui-border);
      border-radius: 8px;
      background: #fff;
      color: #111;
      -moz-appearance: textfield; /* Removes spinner in Firefox */
      -webkit-appearance: none; /* Removes spinner in Chrome/Safari */
      appearance: none; /* Standard property to remove spinner */
      text-align: center; /* Centers text and placeholder */
    }

    /* UPDATED: normalized select centering across browsers */
    select {
      width: 80px; /* Increased width to prevent text cutoff */
      padding: 8px 10px;
      border: 1px solid var(--ui-border);
      border-radius: 8px;
      background: #fff;
      color: #111;

      appearance: none;
      -webkit-appearance: none; /* Removes default arrow in Chrome/Safari */
      -moz-appearance: none;    /* Removes default arrow in Firefox */
      background-image: none;   /* Ensures no default arrow is shown */

      text-align: center;       /* Center in most browsers */

      /* Normalize hidden engine padding/indent that push text right in WebKit */
      text-indent: 0;
      -webkit-padding-start: 10px;
      -webkit-padding-end: 10px;
    }

    /* Hide old IE/Edge chevron */
    select::-ms-expand { display: none; }

    /* Firefox: center the selected value (and optionally dropdown options) */
    @-moz-document url-prefix() {
      select { text-align-last: center; }
      select > option { text-align: center; } /* optional; centers items in the open list */
    }

    input::placeholder { color: #9aa3ad; opacity: 1; }
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

    button {
      padding: 8px 12px;
      border: 1px solid var(--ui-border);
      border-radius: 8px;
      background: #fff;
      color: #111;
      cursor: pointer;
    }
    button:active { transform: translateY(1px); }

    .hint { font-size: 12px; opacity: 0.7; }

    .stage {
      flex: 1 1 auto;
      min-width: 0;
      min-height: 0;
      position: relative;
      background: #fff;
    }
    #grid {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;

      /* IMPORTANT: custom gestures (pinch/pan) handled in JS for consistency with desktop */
      touch-action: none;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="controls" aria-label="Plot point controls">
      <div class="row">
        <select id="modelSelect" aria-label="Choose model">
          <option value="" selected disabled>Model</option>
          <option value="P36">P36</option>
          <option value="D36">D36</option>
        </select>
      </div>

      <div class="row">
        <input id="xmm" type="number" step="1" inputmode="decimal" placeholder="X" aria-label="X coordinate (mm)" />
      </div>
      <div class="row">
        <input id="ymm" type="number" step="1" inputmode="decimal" placeholder="Y" aria-label="Y coordinate (mm)" />
      </div>

      <!-- Reset button on the right -->
      <button id="clearBtn" type="button" title="Reset to default (no model, empty inputs)">Reset</button>
    </div>

    <main class="stage">
      <canvas id="grid" aria-label="Millimeter grid canvas with numeric axis labels"></canvas>
    </main>
  </div>

<script>
  (function () {
    const MM_W = 2100;
    const MM_H = 3700;
    const MAJOR_MM = 100;
    const MINOR_MM = 50;
    const FIT = 'height';

    const MINOR_MM_THICK = 0.25;
    const MAJOR_MM_THICK = 0.5;

    // Labeling config
    const LABEL_MIN_SPACING_PX = 48; // try to keep ~48px between labels
    const LABEL_FONT_PX = 12;        // comfortable, crisp on phones/tablets/desktop

    const MODELS = {
      P36: {
        label: 'P36',
        extraTop: 140,
        svg: 'https://raw.githubusercontent.com/r0wanb3zy/sellwood/48fb4eb18138e5922340c8f00ca5dc6c558d8658/images/grid/P36.svg'
      },
      D36: {
        label: 'D36',
        extraTop: 130,
        svg: 'https://raw.githubusercontent.com/r0wanb3zy/sellwood/db623e0ebb340830cd97cc99f9a4e217a5c5710c/images/grid/D36.svg'
      }
    };

    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d', { alpha: false });

    const modelSelect = document.getElementById('modelSelect');
    const xInput = document.getElementById('xmm');
    const yInput = document.getElementById('ymm');
    const clearBtn = document.getElementById('clearBtn');
    const stage = document.querySelector('.stage');

    const STORAGE_KEY_XY = 'grid-plotter-xy';
    const STORAGE_KEY_MODEL = 'grid-plotter-model';

    const DEFAULT_X = 0;
    const DEFAULT_Y = 0;
    const DEFAULT_MODEL = '';

    let selectedModel = DEFAULT_MODEL;

    // Effective DPR includes pinch-zoom scale (for page zoom outside the canvas)
    let dpr = 1;
    function getEffectiveDpr() {
      const base = Math.max(1, window.devicePixelRatio || 1);
      const zoom = (window.visualViewport && window.visualViewport.scale) ? window.visualViewport.scale : 1;
      return Math.min(6, base * zoom);
    }

    let svgInfo = null;

    function getModelConfig(key = selectedModel) {
      if (!key || !MODELS[key]) return { label: 'None', extraTop: 0, svg: null };
      return MODELS[key];
    }

    // View transform (shared by desktop + mobile)
    const view = { scale: 1, x: 0, y: 0 };
    const VIEW_MIN = 1;
    const VIEW_MAX = 16;

    // Added: helpers to gate panning and snap to default at min zoom
    const EPS = 1e-6;
    const canPan = () => view.scale > VIEW_MIN + EPS;
    function clampViewAtMin() {
      if (view.scale <= VIEW_MIN + EPS) {
        view.scale = VIEW_MIN;
        view.x = 0;
        view.y = 0;
        return true;
      }
      return false;
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function resetView() { view.scale = VIEW_MIN; view.x = 0; view.y = 0; draw(); }

    let rafId = 0;
    function scheduleResize() {
      if (rafId) return;
      rafId = requestAnimationFrame(() => {
        rafId = 0;
        resizeCanvas();
      });
    }

    function resizeCanvas() {
      dpr = getEffectiveDpr();

      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.round(rect.width * dpr));
      const h = Math.max(1, Math.round(rect.height * dpr));

      if (canvas.width !== w) canvas.width = w;
      if (canvas.height !== h) canvas.height = h;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;

      // Ensure default position when at minimum zoom
      clampViewAtMin();

      draw();
    }

    function computeLayout() {
      const { extraTop } = getModelConfig();
      const width = canvas.width / dpr;
      const height = canvas.height / dpr;

      const MM_TOTAL_H = MM_H + extraTop;

      let scale, gridW, gridH, gridLeft, gridTop;

      if (FIT === 'width') {
        scale = width / MM_W;
        gridW = width;
        gridH = MM_TOTAL_H * scale;
        gridLeft = 0;
        gridTop = Math.max(0, (height - gridH) / 2);
      } else if (FIT === 'contain') {
        scale = Math.min(width / MM_W, height / MM_TOTAL_H);
        gridW = MM_W * scale;
        gridH = MM_TOTAL_H * scale;
        gridLeft = Math.max(0, (width - gridW) / 2);
        gridTop = Math.max(0, (height - gridH) / 2);
      } else { // 'height'
        scale = height / MM_TOTAL_H;
        gridH = height;
        gridW = MM_W * scale;
        gridLeft = Math.max(0, (width - gridW) / 2);
        gridTop = 0;
      }
      return { width, height, scale, gridW, gridH, gridLeft, gridTop, extraTop };
    }

    function lineWidths(scale) {
      const minorCss = MINOR_MM_THICK * scale;
      const majorCss = MAJOR_MM_THICK * scale;
      return { minor: minorCss, major: majorCss };
    }

    function crispCoord(v, lineWidthCss) {
      const lwDev = lineWidthCss * dpr;
      const isInt = Math.abs(lwDev - Math.round(lwDev)) < 1e-6;
      const isOddDevicePx = isInt && (Math.round(lwDev) % 2 === 1);
      const centerOffsetDev = isOddDevicePx ? 0.5 : 0;
      return (Math.round(v * dpr) + centerOffsetDev) / dpr;
    }

    function alignToDevicePixel(v) {
      return Math.round(v * dpr) / dpr;
    }

    function draw() {
      const { width, height, scale: baseScale, gridLeft: baseLeft, gridTop: baseTop, extraTop } = computeLayout();

      const mm2px = baseScale * view.scale;

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);

      const gridLeft = baseLeft + view.x;
      const gridTop = baseTop + view.y;

      const { minor, major } = lineWidths(mm2px);

      const gridW = MM_W * mm2px;
      const gridH = (MM_H + extraTop) * mm2px;

      drawGrid({ scale: mm2px, gridW, gridH, gridLeft, gridTop, minorLW: minor, majorLW: major, extraTop });
      drawSvgOverlay({ scale: mm2px, gridLeft, gridTop, extraTop });

      // Axis labels: X pinned to bottom, Y outside the grid's left edge (auto-shift to stay visible)
      drawAxisLabelsPinned({ scale: mm2px, gridLeft, gridTop, extraTop, width, height });

      drawDot({ scale: mm2px, gridLeft, gridTop, extraTop });
    }

    function drawGrid({ scale, gridW, gridH, gridLeft, gridTop, minorLW, majorLW, extraTop }) {
      const minorColor = getComputedStyle(document.documentElement).getPropertyValue('--minor').trim() || '#d9d9d9';
      const majorColor = getComputedStyle(document.documentElement).getPropertyValue('--major').trim() || '#7a7a7a';

      const yMin = -extraTop;
      const yMax = MM_H;

      ctx.save();
      const clipPadding = 1 / dpr;
      ctx.beginPath();
      ctx.rect(gridLeft, gridTop, gridW + clipPadding, gridH);
      ctx.clip();

      // Minor lines
      ctx.strokeStyle = minorColor;
      ctx.lineWidth = minorLW;

      for (let xm = MINOR_MM; xm < MM_W; xm += MINOR_MM) {
        if (xm % MAJOR_MM === 0) continue;
        const x = crispCoord(gridLeft + xm * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(x, gridTop);
        ctx.lineTo(x, gridTop + gridH);
        ctx.stroke();
      }
      for (let ym = Math.ceil(yMin / MINOR_MM) * MINOR_MM; ym < yMax; ym += MINOR_MM) {
        if (ym % MAJOR_MM === 0) continue;
        const y = crispCoord(gridTop + (ym + extraTop) * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(gridLeft, y);
        ctx.lineTo(gridLeft + gridW, y);
        ctx.stroke();
      }

      // Major lines
      ctx.strokeStyle = majorColor;
      ctx.lineWidth = majorLW;

      for (let xm = 0; xm <= MM_W; xm += MAJOR_MM) {
        const x = crispCoord(gridLeft + xm * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(x, gridTop);
        ctx.lineTo(x, gridTop + gridH);
        ctx.stroke();
      }
      for (let ym = Math.ceil(yMin / MAJOR_MM) * MAJOR_MM; ym <= yMax; ym += MAJOR_MM) {
        const y = crispCoord(gridTop + (ym + extraTop) * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(gridLeft, y);
        ctx.lineTo(gridLeft + gridW, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    // Axis labels: X pinned to bottom, Y just outside the grid's left edge.
    // For Y, auto-shift right to keep the entire label visible within the canvas.
    function drawAxisLabelsPinned({ scale, gridLeft, gridTop, extraTop, width, height }) {
      const labelColor = getComputedStyle(document.documentElement).getPropertyValue('--label-color').trim() || '#111';
      const labelHalo  = getComputedStyle(document.documentElement).getPropertyValue('--label-halo').trim()  || 'rgba(255,255,255,0.92)';

      // Choose label step to maintain a minimum pixel spacing
      const stepFactor = Math.max(1, Math.ceil(LABEL_MIN_SPACING_PX / (MAJOR_MM * scale)));
      const step = MAJOR_MM * stepFactor;

      const fontPx = LABEL_FONT_PX;
      const haloWidth = 3; // CSS px halo for contrast

      // Edges/margins
      const margin = 6;      // distance from canvas edges
      const outsideGap = 6;  // gap between grid and Y labels when the grid's left edge is visible

      // Visible world ranges (clamped to grid domain)
      const xMinMmVisible = Math.max(0, (0 - gridLeft) / scale);
      const xMaxMmVisible = Math.min(MM_W, (width - gridLeft) / scale);

      const yMinMmVisible = Math.max(0, (0 - gridTop) / scale - extraTop);
      const yMaxMmVisible = Math.min(MM_H, (height - gridTop) / scale - extraTop);

      // Bottom X labels (pinned to bottom of canvas)
      if (xMaxMmVisible >= 0 && xMinMmVisible <= MM_W) {
        ctx.save();
        ctx.font = `600 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.lineJoin = 'round';
        ctx.miterLimit = 2;

        const yBottom = height - margin;

        const startX = Math.ceil(xMinMmVisible / step) * step;
        for (let xm = startX; xm <= xMaxMmVisible; xm += step) {
          const sx = alignToDevicePixel(gridLeft + xm * scale);
          const text = String(xm);
          ctx.lineWidth = haloWidth;
          ctx.strokeStyle = labelHalo;
          ctx.strokeText(text, sx, yBottom);
          ctx.fillStyle = labelColor;
          ctx.fillText(text, sx, yBottom);
        }
        ctx.restore();
      }

      // Left Y labels (outside the grid's left edge; auto-shift to keep fully visible)
      if (yMaxMmVisible >= 0 && yMinMmVisible <= MM_H) {
        ctx.save();
        ctx.font = `600 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial`;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.lineJoin = 'round';
        ctx.miterLimit = 2;

        // Prepare list of visible labels to measure max width
        const labels = [];
        const startY = Math.ceil(yMinMmVisible / step) * step;
        for (let ym = startY; ym <= yMaxMmVisible; ym += step) {
          labels.push(String(ym));
        }

        // Measure widest visible label to avoid left-edge clipping
        let maxW = 0;
        for (const txt of labels) {
          const w = ctx.measureText(txt).width;
          if (w > maxW) maxW = w;
        }
        const haloPad = Math.ceil(haloWidth / 2) + 1; // keep halo off the edge

        // Desired position: just outside the grid's left edge
        const desiredRightX = gridLeft - outsideGap;

        // Minimum right-edge X so the whole text stays within the canvas
        const minRightX = margin + maxW + haloPad;

        const xRight = alignToDevicePixel(Math.max(desiredRightX, minRightX));

        // Draw labels
        for (let i = 0; i < labels.length; i++) {
          const ym = startY + i * step;
          const sy = alignToDevicePixel(gridTop + (extraTop + ym) * scale);
          const text = labels[i];
          ctx.lineWidth = haloWidth;
          ctx.strokeStyle = labelHalo;
          ctx.strokeText(text, xRight, sy);
          ctx.fillStyle = labelColor;
          ctx.fillText(text, xRight, sy);
        }
        ctx.restore();
      }
    }

    function drawDot({ scale, gridLeft, gridTop, extraTop }) {
      const xParsed = parseFloat(xInput.value);
      const yParsed = parseFloat(yInput.value);
      const xmm = Number.isFinite(xParsed) ? xParsed : DEFAULT_X;
      const ymm = Number.isFinite(yParsed) ? yParsed : DEFAULT_Y;

      const x = gridLeft + xmm * scale;
      const y = gridTop + (extraTop + ymm) * scale;

      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#e53935';

      // Keep dot a constant on-screen size (compensate for page pinch-zoom outside canvas)
      const pageZoom = (window.visualViewport && window.visualViewport.scale) ? window.visualViewport.scale : 1;
      const rCssBase = 4;           // base radius in CSS px at pageZoom = 1
      const rCss = rCssBase / pageZoom; // normalize by visual viewport zoom

      const cx = alignToDevicePixel(x);
      const cy = alignToDevicePixel(y);

      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, rCss, 0, Math.PI * 2);
      ctx.fillStyle = accent;
      ctx.fill();
      ctx.restore();
    }

    function drawSvgOverlay({ scale, gridLeft, gridTop, extraTop }) {
      if (!svgInfo || !svgInfo.img || !svgInfo.mmSize.width || !svgInfo.mmSize.height) return;

      const destW = svgInfo.mmSize.width * scale;
      const destH = svgInfo.mmSize.height * scale;
      const dx = gridLeft;
      const dy = gridTop;

      ctx.save();
      const half = 0.5 / dpr;
      ctx.beginPath();
      ctx.rect(gridLeft - half, gridTop - half, MM_W * scale + 2 * half, (MM_H + extraTop) * scale + 2 * half);
      ctx.clip();

      ctx.drawImage(svgInfo.img, dx, dy, destW, destH);
      ctx.restore();
    }

    function parseLengthToMm(val) {
      if (!val) return null;
      const m = String(val).trim().match(/^(-?\d+(\.\d+)?)([a-z%]*)$/i);
      if (!m) return null;
      const num = parseFloat(m[1]);
      const unit = (m[3] || '').toLowerCase();
      const mmPerUnit = {
        mm: 1, cm: 10, in: 25.4, pt: 25.4 / 72, pc: 25.4 / 6, px: 25.4 / 96, q: 0.25
      };
      const k = unit ? mmPerUnit[unit] : 1;
      if (!k) return null;
      return num * k;
    }

    async function loadSvgInfo(url) {
      const [img, meta] = await Promise.all([
        new Promise((resolve, reject) => {
          const i = new Image();
          i.crossOrigin = 'anonymous';
          i.onload = () => resolve(i);
          i.onerror = reject;
          i.src = url;
        }),
        fetch(url, { mode: 'cors' })
          .then(r => r.text())
          .then(txt => {
            const doc = new DOMParser().parseFromString(txt, 'image/svg+xml');
            const svg = doc.documentElement;
            const viewBox = svg.getAttribute('viewBox');
            let minX = 0, minY = 0, vbW = 0, vbH = 0;
            if (viewBox) {
              const p = viewBox.trim().split(/[\s,]+/).map(Number);
              if (p.length === 4) [minX, minY, vbW, vbH] = p;
            }
            const widthMm = parseLengthToMm(svg.getAttribute('width'));
            const heightMm = parseLengthToMm(svg.getAttribute('height'));

            let mmPerUnitX = (vbW && widthMm != null) ? widthMm / vbW : null;
            let mmPerUnitY = (vbH && heightMm != null) ? heightMm / vbH : null;
            if (mmPerUnitX == null && mmPerUnitY != null) mmPerUnitX = mmPerUnitY;
            if (mmPerUnitY == null && mmPerUnitX != null) mmPerUnitY = mmPerUnitX;
            if (mmPerUnitX == null || mmPerUnitY == null) {
              mmPerUnitX = mmPerUnitY = 1;
            }

            const mmW = widthMm ?? (vbW ? vbW * mmPerUnitX : null);
            const mmH = heightMm ?? (vbH ? vbH * mmPerUnitY : null);

            return {
              vb: { minX, minY, width: vbW, height: vbH },
              mmSize: { width: mmW, height: mmH },
              mmPerUnit: { x: mmPerUnitX, y: mmPerUnitY }
            };
          })
      ]);
      return { img, ...meta };
    }

    // Persistence
    function saveXY() {
      try {
        const data = { x: xInput.value, y: yInput.value };
        localStorage.setItem(STORAGE_KEY_XY, JSON.stringify(data));
      } catch (e) {}
    }
    function restoreXY() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY_XY);
        if (!raw) return;
        const { x, y } = JSON.parse(raw);
        if (x !== undefined && x !== null) xInput.value = x;
        if (y !== undefined && y !== null) yInput.value = y;
      } catch (e) {}
    }

    function saveModel() {
      try {
        localStorage.setItem(STORAGE_KEY_MODEL, selectedModel || '');
      } catch (e) {}
    }
    function restoreModel() {
      try {
        const m = localStorage.getItem(STORAGE_KEY_MODEL) || '';
        if (m && MODELS[m]) {
          modelSelect.value = m;
          setModel(m);
        } else {
          modelSelect.value = '';
          setModel('');
        }
      } catch (e) {
        setModel('');
      }
    }

    function setModel(key) {
      selectedModel = (key && MODELS[key]) ? key : DEFAULT_MODEL;

      svgInfo = null;

      const { svg } = getModelConfig();
      if (svg) {
        loadSvgInfo(svg)
          .then(info => { svgInfo = info; draw(); })
          .catch(err => console.error('SVG load/parse failed:', err));
      }

      draw();
    }

    function enableSelectAllOnFocus(el) {
      el.addEventListener('focus', () => {
        setTimeout(() => {
          try { el.select(); el.setSelectionRange?.(0, 9999); } catch (e) {}
        }, 0);
      });

      const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
      if (!isTouch) {
        el.addEventListener('mouseup', e => e.preventDefault());
      }
    }

    // Wheel zoom: in to mouse, out toward default (no snap)
    function wheelZoomHandler(e) {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;

      const { scale: baseScale, gridLeft: baseLeft, gridTop: baseTop } = computeLayout();

      const deltaPx = (e.deltaMode === 1) ? (e.deltaY * 16)
                    : (e.deltaMode === 2) ? (e.deltaY * rect.height)
                    : e.deltaY;

      const factor = Math.exp(-deltaPx / 300);

      const prevVS = view.scale;
      let nextVS = clamp(prevVS * factor, VIEW_MIN, VIEW_MAX);
      if (Math.abs(nextVS - prevVS) < 1e-6) return;

      const ratio = nextVS / prevVS;

      // Choose zoom anchor
      let anchorX, anchorY;

      if (nextVS > prevVS) {
        // Zoom in: anchor at cursor
        anchorX = px;
        anchorY = py;
      } else {
        // Zoom out: anchor toward default so that when we hit min, pan -> 0 with no snap
        const S = baseScale * prevVS;
        const Smin = baseScale * VIEW_MIN;
        if (S - Smin < 1e-6) {
          anchorX = baseLeft;
          anchorY = baseTop;
        } else {
          const axOff = -view.x * Smin / (S - Smin);
          const ayOff = -view.y * Smin / (S - Smin);
          anchorX = baseLeft + axOff;
          anchorY = baseTop + ayOff;
        }
      }

      // Apply zoom around anchor
      view.x = view.x * ratio + (anchorX - baseLeft) * (1 - ratio);
      view.y = view.y * ratio + (anchorY - baseTop) * (1 - ratio);
      view.scale = nextVS;

      // Snap to exact default when reaching minimum zoom
      clampViewAtMin();

      draw();
    }

    // Pointer-based pan and pinch (mobile + also works on desktop)
    const pointers = new Map(); // id -> {x, y}
    const pan = { active: false, lastX: 0, lastY: 0 };
    const pinch = {
      active: false,
      startScale: 1,
      startViewX: 0,
      startViewY: 0,
      startCenterX: 0,
      startCenterY: 0,
      startDist: 0
    };

    function getCanvasPoint(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    function updatePointer(e) {
      pointers.set(e.pointerId, getCanvasPoint(e));
    }

    function startPinchBaseline() {
      const pts = [...pointers.values()];
      if (pts.length < 2) return;
      const p1 = pts[0], p2 = pts[1];
      pinch.active = true;
      pinch.startScale = view.scale;
      pinch.startViewX = view.x;
      pinch.startViewY = view.y;
      pinch.startCenterX = (p1.x + p2.x) / 2;
      pinch.startCenterY = (p1.y + p2.y) / 2;
      pinch.startDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }

    // Updated: snap back to default when zoomed to min, and only allow pan when zoomed-in
    function handlePinch() {
      const pts = [...pointers.values()];
      if (pts.length < 2) return;
      const { scale: baseScale, gridLeft: baseLeft, gridTop: baseTop } = computeLayout();

      const p1 = pts[0], p2 = pts[1];
      const centerX = (p1.x + p2.x) / 2;
      const centerY = (p1.y + p2.y) / 2;
      const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);

      if (!pinch.active) startPinchBaseline();
      if (pinch.startDist <= 0) return;

      const rawScale = pinch.startScale * (dist / pinch.startDist);
      const newScale = clamp(rawScale, VIEW_MIN, VIEW_MAX);

      // Lock to default when at or under min zoom
      if (newScale <= VIEW_MIN + EPS) {
        view.scale = VIEW_MIN;
        view.x = 0;
        view.y = 0;
        draw();
        return;
      }

      const ratio = newScale / pinch.startScale;

      // Keep the world point under the initial pinch center "locked" under the current center
      view.x = pinch.startViewX * ratio + (centerX - baseLeft) - (pinch.startCenterX - baseLeft) * ratio;
      view.y = pinch.startViewY * ratio + (centerY - baseTop) - (pinch.startCenterY - baseTop) * ratio;
      view.scale = newScale;

      draw();
    }

    function onPointerDown(e) {
      canvas.setPointerCapture?.(e.pointerId);
      updatePointer(e);
      e.preventDefault();

      if (pointers.size === 1) {
        const p = [...pointers.values()][0];
        if (canPan()) {
          pan.active = true;
          pan.lastX = p.x;
          pan.lastY = p.y;
        } else {
          pan.active = false; // locked at min zoom
        }
        pinch.active = false;
      } else if (pointers.size === 2) {
        pan.active = false;
        startPinchBaseline();
      }
    }

    function onPointerMove(e) {
      if (!pointers.has(e.pointerId)) return;
      updatePointer(e);
      e.preventDefault();

      if (pointers.size === 1 && pan.active) {
        const p = [...pointers.values()][0];
        const dx = p.x - pan.lastX;
        const dy = p.y - pan.lastY;
        pan.lastX = p.x;
        pan.lastY = p.y;
        view.x += dx;
        view.y += dy;
        draw();
      } else if (pointers.size >= 2) {
        handlePinch();
      }
    }

    function onPointerUp(e) {
      if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);
      e.preventDefault();

      if (pointers.size === 0) {
        pan.active = false;
        pinch.active = false;
        // If we ended at min, snap back to default position
        if (clampViewAtMin()) draw();
      } else if (pointers.size === 1) {
        // Continue panning with remaining finger only if zoomed-in
        const p = [...pointers.values()][0];
        pan.active = canPan();
        pan.lastX = p.x;
        pan.lastY = p.y;
        pinch.active = false;
      } else if (pointers.size >= 2) {
        // Rebaseline if pointer count changes
        startPinchBaseline();
      }
    }

    // Init
    restoreXY();
    resizeCanvas();
    restoreModel(); // may trigger draw again after SVG load

    window.addEventListener('resize', scheduleResize);
    window.addEventListener('orientationchange', scheduleResize);

    if ('ResizeObserver' in window) {
      const ro = new ResizeObserver(() => scheduleResize());
      ro.observe(stage);
    }

    if (window.visualViewport) {
      visualViewport.addEventListener('resize', scheduleResize, { passive: true });
      visualViewport.addEventListener('scroll', scheduleResize, { passive: true });
    }

    xInput.addEventListener('input', () => { saveXY(); draw(); });
    yInput.addEventListener('input', () => { saveXY(); draw(); });
    [xInput, yInput].forEach(el =>
      el.addEventListener('keydown', e => { if (e.key === 'Enter') { saveXY(); draw(); } })
    );

    modelSelect.addEventListener('change', (e) => {
      setModel(e.target.value);
      saveModel();
    });

    [xInput, yInput].forEach(enableSelectAllOnFocus);

    // Reset button: clear inputs to show placeholders, keep current model and view
    clearBtn.addEventListener('click', () => {
      xInput.value = '';
      yInput.value = '';
      saveXY();
      draw();
    });

    // Desktop wheel zoom
    canvas.addEventListener('wheel', wheelZoomHandler, { passive: false });
    canvas.addEventListener('dblclick', resetView);

    // Mobile/Pointer gestures
    canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
    canvas.addEventListener('pointermove', onPointerMove, { passive: false });
    canvas.addEventListener('pointerup', onPointerUp, { passive: false });
    canvas.addEventListener('pointercancel', onPointerUp, { passive: false });
    canvas.addEventListener('lostpointercapture', onPointerUp, { passive: false });
  })();
</script>
</body>
</html>
