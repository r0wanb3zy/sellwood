<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Make the VK (virtual keyboard) overlay content instead of resizing it, where supported -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, interactive-widget=overlays-content" />
  <title>2100Ã—3700 mm Grid Plotter (no labels)</title>
  <style>
    :root {
      --ui-bg: #f8f9fb;
      --ui-border: rgba(0, 0, 0, 0.12);
      --minor: #d9d9d9;
      --major: #7a7a7a;
      --accent: #e53935;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    /* Prevent window scrolling that can fight with gestures */
    body {
      font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Helvetica, Arial;
      color: #222;
      background: #fff;
      overflow: hidden; /* keep viewport stable when VK shows */
    }

    /* App layout: controls on top, grid fills remaining height */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh; /* fallback */
      width: 100%;
    }
    /* Prefer the largest viewport height so the grid doesn't shrink under VK */
    @supports (height: 100lvh) {
      .app { height: 100lvh; }
    }

    /* Top-centered controls */
    .controls {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 14px;
      padding: 10px;
      background: var(--ui-bg);
      border-bottom: 1px solid var(--ui-border);
      flex-wrap: wrap;
      position: sticky; /* keeps controls at top if anything scrolls */
      top: 0;
      z-index: 10;
    }
    .row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    label { font-size: 13px; }
    input[type="number"] {
      width: 80px;
      padding: 8px 10px;
      border: 1px solid var(--ui-border);
      border-radius: 8px;
      background: #fff;
      color: #111;
      -moz-appearance: textfield;
      font-size: 16px; /* iOS: prevent auto zoom on focus */
    }
    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .hint { font-size: 12px; opacity: 0.7; }

    .stage {
      flex: 1 1 auto;
      min-width: 0;
      min-height: 0;
      position: relative;
      background: #fff;
      overscroll-behavior: contain; /* avoid rubber-banding while panning/zooming */
    }
    #grid {
      width: 100%;
      height: 100%;
      display: block;
      background: #fff;
      touch-action: none; /* we implement pan/zoom ourselves */
      user-select: none;
      -webkit-user-select: none;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="controls" aria-label="Plot point controls">
      <div class="row">
        <input id="xmm" type="number" step="1" value="0" inputmode="decimal" />
      </div>
      <div class="row">
        <input id="ymm" type="number" step="1" value="0" inputmode="decimal" />
      </div>
    </div>

    <main class="stage">
      <canvas id="grid" aria-label="Millimeter grid canvas without labels"></canvas>
    </main>
  </div>

<script>
  (function () {
    const MM_W = 2100;      // grid width in mm
    const MM_H = 3700;      // grid height in mm
    const EXTRA_TOP_MM = 130; // visible headroom above 0 (negative Y)
    const MAJOR_MM = 100;   // major step
    const MINOR_MM = 50;    // minor step
    const FIT = 'height';   // fill stage height

    // Overlay SVG
    const SVG_URL = 'https://raw.githubusercontent.com/r0wanb3zy/sellwood/e57f46fdb25d93cff84288774fd70e243d472d02/images/grid/D36.svg';

    const canvas = document.getElementById('grid');
    const ctx = canvas.getContext('2d', { alpha: false });

    const xInput = document.getElementById('xmm');
    const yInput = document.getElementById('ymm');
    const stage = document.querySelector('.stage');

    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let svgInfo = null; // loaded SVG + size in mm

    // View transform for pinch-zoom + pan
    const view = {
      zoom: 1,
      panX: 0,
      panY: 0,
      minZoom: 0.5,
      maxZoom: 8
    };

    function clamp(v, a, b) { return Math.min(b, Math.max(a, v)); }

    function resizeCanvas() {
      dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      canvas.width  = Math.max(1, Math.round(rect.width * dpr));
      canvas.height = Math.max(1, Math.round(rect.height * dpr));
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      draw();
    }

    function computeLayout() {
      const width = canvas.width / dpr;
      const height = canvas.height / dpr;
      const MM_TOTAL_H = MM_H + EXTRA_TOP_MM;

      let scale, gridW, gridH, gridLeft, gridTop;

      if (FIT === 'width') {
        scale = width / MM_W;
        gridW = width;
        gridH = MM_TOTAL_H * scale;
        gridLeft = 0;
        gridTop = Math.max(0, (height - gridH) / 2);
      } else if (FIT === 'contain') {
        scale = Math.min(width / MM_W, height / MM_TOTAL_H);
        gridW = MM_W * scale;
        gridH = MM_TOTAL_H * scale;
        gridLeft = Math.max(0, (width - gridW) / 2);
        gridTop = Math.max(0, (height - gridH) / 2);
      } else { // 'height'
        scale = height / MM_TOTAL_H;
        gridH = height;
        gridW = MM_W * scale;
        gridLeft = Math.max(0, (width - gridW) / 2);
        gridTop = 0;
      }
      return { width, height, scale, gridW, gridH, gridLeft, gridTop };
    }

    function lineWidths() {
      const minor = (dpr >= 1) ? 0.5 : .5;
      const major = (dpr >= 1) ? 0.5 : .5;
      return { minor, major };
    }

    function crispCoord(v, lineWidth) {
      const isFractional = Math.abs(lineWidth - Math.round(lineWidth)) > 1e-6;
      const isOddInt = !isFractional && (Math.round(lineWidth) % 2 === 1);
      if (isFractional || isOddInt) return Math.floor(v) + 0.5;
      return Math.round(v);
    }

    function draw() {
      const base = computeLayout();

      // Apply interactive transform
      const scale = base.scale * view.zoom;
      const gridLeft = base.gridLeft + view.panX;
      const gridTop = base.gridTop + view.panY;
      const gridW = MM_W * scale;
      const gridH = (MM_H + EXTRA_TOP_MM) * scale;

      const { width, height } = base;
      const { minor, major } = lineWidths();

      // Clear
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, width, height);

      drawGrid({ scale, gridW, gridH, gridLeft, gridTop, minorLW: minor, majorLW: major });
      drawSvgOverlay({ scale, gridLeft, gridTop });
      drawDot({ scale, gridLeft, gridTop });
    }

    function drawGrid({ scale, gridW, gridH, gridLeft, gridTop, minorLW, majorLW }) {
      const minorColor = getComputedStyle(document.documentElement).getPropertyValue('--minor').trim() || '#d9d9d9';
      const majorColor = getComputedStyle(document.documentElement).getPropertyValue('--major').trim() || '#7a7a7a';

      const yMin = -EXTRA_TOP_MM;
      const yMax = MM_H;

      ctx.save();
      ctx.beginPath();
      ctx.rect(gridLeft, gridTop, gridW, gridH);
      ctx.clip();

      // Minor lines (every 50 mm)
      ctx.strokeStyle = minorColor;
      ctx.lineWidth = minorLW;

      // Vertical (X) minor lines
      for (let xm = MINOR_MM; xm < MM_W; xm += MINOR_MM) {
        if (xm % MAJOR_MM === 0) continue;
        const x = crispCoord(gridLeft + xm * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(x, gridTop);
        ctx.lineTo(x, gridTop + gridH);
        ctx.stroke();
      }
      // Horizontal (Y) minor lines include negatives
      for (let ym = Math.ceil(yMin / MINOR_MM) * MINOR_MM; ym < yMax; ym += MINOR_MM) {
        if (ym % MAJOR_MM === 0) continue;
        const y = crispCoord(gridTop + (ym + EXTRA_TOP_MM) * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(gridLeft, y);
        ctx.lineTo(gridLeft + gridW, y);
        ctx.stroke();
      }

      // Major lines (every 100 mm)
      ctx.strokeStyle = majorColor;
      ctx.lineWidth = majorLW;

      for (let xm = 0; xm <= MM_W; xm += MAJOR_MM) {
        const x = crispCoord(gridLeft + xm * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(x, gridTop);
        ctx.lineTo(x, gridTop + gridH);
        ctx.stroke();
      }
      for (let ym = Math.ceil(yMin / MAJOR_MM) * MAJOR_MM; ym <= yMax; ym += MAJOR_MM) {
        const y = crispCoord(gridTop + (ym + EXTRA_TOP_MM) * scale, ctx.lineWidth);
        ctx.beginPath();
        ctx.moveTo(gridLeft, y);
        ctx.lineTo(gridLeft + gridW, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawDot({ scale, gridLeft, gridTop }) {
      const xmm = parseFloat(xInput.value);
      const ymm = parseFloat(yInput.value);
      if (!isFinite(xmm) || !isFinite(ymm)) return;

      const x = gridLeft + xmm * scale;
      const y = gridTop + (EXTRA_TOP_MM + ymm) * scale;
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#e53935';

      const r = 2.5;
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = accent;
      ctx.fill();
      ctx.restore();
    }

    // Draw the SVG on top of the grid at 1:1 mm scale, anchored at 0 mm
    function drawSvgOverlay({ scale, gridLeft, gridTop }) {
      if (!svgInfo || !svgInfo.img || !svgInfo.mmSize.width || !svgInfo.mmSize.height) return;

      const destW = svgInfo.mmSize.width * scale;   // px
      const destH = svgInfo.mmSize.height * scale;  // px
      const dx = gridLeft;                          // align left to grid
      const dy = gridTop;                           // align top to extended grid

      ctx.save();
      // Clip to the grid bounds (includes the extra top mm)
      ctx.beginPath();
      ctx.rect(gridLeft, gridTop, MM_W * scale, (MM_H + EXTRA_TOP_MM) * scale);
      ctx.clip();

      ctx.drawImage(svgInfo.img, dx, dy, destW, destH);
      ctx.restore();
    }

    // Helpers: load/measure the SVG in mm
    function parseLengthToMm(val) {
      if (!val) return null;
      const m = String(val).trim().match(/^(-?\d+(\.\d+)?)([a-z%]*)$/i);
      if (!m) return null;
      const num = parseFloat(m[1]);
      const unit = (m[3] || '').toLowerCase();
      const mmPerUnit = {
        mm: 1,
        cm: 10,
        in: 25.4,
        pt: 25.4 / 72,
        pc: 25.4 / 6,
        px: 25.4 / 96,
        q: 0.25
      };
      const k = unit ? mmPerUnit[unit] : 1; // no unit => assume mm
      if (!k) return null;
      return num * k;
    }

    async function loadSvgInfo(url) {
      const [img, meta] = await Promise.all([
        new Promise((resolve, reject) => {
          const i = new Image();
          i.crossOrigin = 'anonymous';
          i.onload = () => resolve(i);
          i.onerror = reject;
          i.src = url;
        }),
        fetch(url, { mode: 'cors' })
          .then(r => r.text())
          .then(txt => {
            const doc = new DOMParser().parseFromString(txt, 'image/svg+xml');
            const svg = doc.documentElement;
            const viewBox = svg.getAttribute('viewBox');
            let minX = 0, minY = 0, vbW = 0, vbH = 0;
            if (viewBox) {
              const p = viewBox.trim().split(/[\s,]+/).map(Number);
              if (p.length === 4) [minX, minY, vbW, vbH] = p;
            }
            const widthMm = parseLengthToMm(svg.getAttribute('width'));
            const heightMm = parseLengthToMm(svg.getAttribute('height'));

            let mmPerUnitX = (vbW && widthMm != null) ? widthMm / vbW : null;
            let mmPerUnitY = (vbH && heightMm != null) ? heightMm / vbH : null;
            if (mmPerUnitX == null && mmPerUnitY != null) mmPerUnitX = mmPerUnitY;
            if (mmPerUnitY == null && mmPerUnitX != null) mmPerUnitY = mmPerUnitX;
            if (mmPerUnitX == null || mmPerUnitY == null) {
              mmPerUnitX = mmPerUnitY = 1;
            }

            const mmW = widthMm ?? (vbW ? vbW * mmPerUnitX : null);
            const mmH = heightMm ?? (vbH ? vbH * mmPerUnitY : null);

            return {
              vb: { minX, minY, width: vbW, height: vbH },
              mmSize: { width: mmW, height: mmH },
              mmPerUnit: { x: mmPerUnitX, y: mmPerUnitY }
            };
          })
      ]);
      return { img, ...meta };
    }

    // Init
    resizeCanvas();

    // Load overlay then draw
    loadSvgInfo(SVG_URL)
      .then(info => { svgInfo = info; draw(); })
      .catch(err => console.error('SVG load/parse failed:', err));

    // Keep canvas sized to viewport and layout changes
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);

    if ('ResizeObserver' in window) {
      const ro = new ResizeObserver(() => resizeCanvas());
      ro.observe(stage);
    }

    // Dynamic inputs
    xInput.addEventListener('input', draw);
    yInput.addEventListener('input', draw);
    [xInput, yInput].forEach(el =>
      el.addEventListener('keydown', e => { if (e.key === 'Enter') draw(); })
    );

    // ----- Pointer interactions: pan + pinch zoom -----
    const active = new Map();
    let gesture = null;
    let rafId = 0;
    function requestDraw() {
      if (rafId) return;
      rafId = requestAnimationFrame(() => { rafId = 0; draw(); });
    }

    function getLocal(e) {
      const r = canvas.getBoundingClientRect();
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      canvas.setPointerCapture(e.pointerId);
      const p = getLocal(e);
      active.set(e.pointerId, p);

      if (active.size === 2) {
        startPinch();
      } else if (active.size === 1) {
        gesture = { type: 'pan', last: p };
      }
    }, { passive: false });

    canvas.addEventListener('pointermove', (e) => {
      if (!active.has(e.pointerId)) return;
      e.preventDefault();
      const p = getLocal(e);
      active.set(e.pointerId, p);

      if (active.size === 1 && gesture && gesture.type === 'pan') {
        const dx = p.x - gesture.last.x;
        const dy = p.y - gesture.last.y;
        view.panX += dx;
        view.panY += dy;
        gesture.last = p;
        requestDraw();
      } else if (active.size >= 2 && gesture && gesture.type === 'pinch') {
        const pts = [...active.values()];
        const center = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 };
        const dist = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);

        const base = computeLayout();
        const targetZoom = clamp(gesture.initZoom * (dist / gesture.initDist), view.minZoom, view.maxZoom);

        const RS0 = gesture.prevRS;
        const RS1 = base.scale * targetZoom;
        const r = RS1 / RS0;

        // Translate by center movement
        view.panX += center.x - gesture.prevCenter.x;
        view.panY += center.y - gesture.prevCenter.y;

        // Scale around current center
        view.panX = r * view.panX + (1 - r) * (center.x - base.gridLeft);
        view.panY = r * view.panY + (1 - r) * (center.y - base.gridTop);

        // Commit
        view.zoom = targetZoom;
        gesture.prevCenter = center;
        gesture.prevRS = RS1;
        requestDraw();
      }
    }, { passive: false });

    function startPinch() {
      const pts = [...active.values()];
      const center = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 };
      const dist = Math.hypot(pts[1].x - pts[0].x, pts[1].y - pts[0].y);
      const base = computeLayout();
      gesture = {
        type: 'pinch',
        initDist: dist,
        initZoom: view.zoom,
        prevCenter: center,
        prevRS: base.scale * view.zoom
      };
    }

    function endPointer(e) {
      if (active.has(e.pointerId)) active.delete(e.pointerId);
      if (active.size === 0) {
        gesture = null;
      } else if (active.size === 1) {
        // switch back to pan with the remaining pointer
        const remaining = [...active.values()][0];
        gesture = { type: 'pan', last: remaining };
      }
    }

    canvas.addEventListener('pointerup', endPointer, { passive: false });
    canvas.addEventListener('pointercancel', endPointer, { passive: false });
    canvas.addEventListener('pointerleave', endPointer, { passive: false });

    // Optional: double-tap to reset view
    let lastTapTime = 0;
    canvas.addEventListener('pointerdown', (e) => {
      if (active.size > 1) return;
      const now = performance.now();
      if (now - lastTapTime < 300) {
        // reset
        view.zoom = 1;
        view.panX = 0;
        view.panY = 0;
        draw();
      }
      lastTapTime = now;
    });

  })();
</script>
</body>
</html>
